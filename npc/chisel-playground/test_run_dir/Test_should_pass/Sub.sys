Sub
input reset : bv<1>
input io_a : bv<4>
input io_b : bv<4>
node _io_c_T : bv<4> = not(io_b)
node _io_c_T_1 : bv<5> = add(zext(io_a, 1), zext(_io_c_T, 1))
node _io_c_T_2 : bv<4> = _io_c_T_1[3:0]
node _io_c_T_3 : bv<5> = add(zext(_io_c_T_2, 1), zext(1'b1, 4))
node _ref_T : bv<5> = sub(zext(io_a, 1), zext(io_b, 1))
node ref : bv<4> = _ref_T[3:0]
output io_c : bv<4> = _io_c_T_3[3:0]
node _T : bv<1> = eq(io_c, ref)
node _T_1 : bv<1> = not(reset)
node _T_2 : bv<1> = not(_T)
node _resetPhase : bv<1> = not(ugeq(_resetCount, 1'b1))
bad assert : bv<1> = not(implies(_T_1, _T))
constraint _resetActive : bv<1> = implies(_resetPhase, reset)
state _resetCount : bv<1>
  [init] 1'b0
  [next] ite(_resetPhase, add(zext(_resetCount, 1), zext(1'b1, 1))[0], _resetCount)